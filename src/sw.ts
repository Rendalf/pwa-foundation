import 'manifest.json'
import { cacheFirstStrategy } from 'service-worker/strategies'

const SW: ServiceWorkerGlobalScope = self as any

declare const serviceWorkerOption: {
  assets: string[]
}

const CACHED_PAGES_PATHNAMES = [
  '/',
]

const HMR_FILE_REGEXP = /\.hot-update\.js(on)?$/

const CACHED_RESOURCES = serviceWorkerOption.assets
  // filter out dev-server runtime things
  .filter((asset) => !HMR_FILE_REGEXP.test(asset))
  .filter((asset) => !/\.html$/.test(asset))
  .concat(...CACHED_PAGES_PATHNAMES)

const CACHED_RESOURCES_SET = new Set(CACHED_RESOURCES)

// TODO dynamic cache name per releases
const CACHE_NAME = 'my_pwa_0.0.1'


// cache generated by webpack files on installation
SW.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(CACHED_RESOURCES))
      .then(() => SW.skipWaiting())
  )
})

// clear unused caches on activation
SW.addEventListener('activate', (event) => {
  const cacheWhiteList = new Set([CACHE_NAME])

  event.waitUntil(
    caches.keys()
      .then((keyList) =>
        Promise.all(
          keyList.reduce<Promise<boolean>[]>((result, key) => {
            if (!cacheWhiteList.has(key)) {
              result.push(caches.delete(key))
            }

            return result
          }, [])
        )
      )
      .then(() => SW.clients.claim())
  )
})

// TODO add another extensions: fonts, images
function isRequestForCacheFirstStatic (request: Request): boolean {
  if (!request.url.startsWith(SW.registration.scope)) {
    return false
  }

  const requestPathname = request.url.slice(SW.registration.scope.length - 1)
  return CACHED_RESOURCES_SET.has(requestPathname)
}

SW.addEventListener('fetch', (event) => {
  if (isRequestForCacheFirstStatic(event.request)) {
    // cache-first for internal static
    event.respondWith(
      caches.open(CACHE_NAME)
        .then((cache) => cacheFirstStrategy(event, cache))
    )
    return
  }
})
