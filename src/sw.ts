import { cacheFirstStrategy } from 'service-worker/strategies'

const SW: ServiceWorkerGlobalScope = self as any

declare const serviceWorkerOption: {
  assets: string[]
}

const CACHED_PAGES_PATHNAMES = [
  '/',
]

const CACHED_PAGES_URLS_SET = new Set(
  CACHED_PAGES_PATHNAMES.map((pathname) =>
    SW.registration.scope.concat(pathname.slice(1))
  )
)

const CACHED_RESOURCES = serviceWorkerOption.assets
  // filter out dev-server runtime things
  .filter((asset) => !/\.hot-update\.js(on)?$/.test(asset))
  .filter((asset) => !/\.html$/.test(asset))
  .concat(...CACHED_PAGES_PATHNAMES)

// TODO dynamic cache name per releases
const CACHE_NAME = 'my_pwa_0.0.1'


// cache generated by webpack files on installation
SW.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(CACHED_RESOURCES))
      .then(() => SW.skipWaiting())
  )
})

// clear unused caches on activation
SW.addEventListener('activate', (event) => {
  const cacheWhiteList = new Set([CACHE_NAME])

  event.waitUntil(
    caches.keys()
      .then((keyList) =>
        Promise.all(
          keyList.reduce<Promise<boolean>[]>((result, key) => {
            if (!cacheWhiteList.has(key)) {
              result.push(caches.delete(key))
            }

            return result
          }, [])
        )
      )
      .then(() => SW.clients.claim())
  )
})

// TODO add another extensions: fonts, images
function isRequestForCacheFirstStatic (request: Request): boolean {
  if (CACHED_PAGES_URLS_SET.has(request.url)) {
    return true
  }

  // ignore hot updates
  if (/\.hot-update\.js$/.test(request.url)) {
    return false
  }

  return /\.(css|js)$/.test(request.url)
}

SW.addEventListener('fetch', (event) => {
  if (isRequestForCacheFirstStatic(event.request)) {
    // cache-first for internal static
    event.respondWith(
      caches.open(CACHE_NAME)
        .then((cache) => cacheFirstStrategy(event, cache))
    )
    return
  }
})
