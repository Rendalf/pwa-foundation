import { cacheFirstStrategy } from 'service-worker/strategies'
import { isClientFocused } from 'service-worker/helpers'

const SW: ServiceWorkerGlobalScope = self as any

declare const serviceWorkerOption: {
  assets: string[]
}

const CACHED_PAGES_PATHNAMES = [
  '/',
]

const HMR_FILE_REGEXP = /\.hot-update\.js(on)?$/

const CACHED_RESOURCES = serviceWorkerOption.assets
  // filter out dev-server runtime things
  .filter((asset) => !HMR_FILE_REGEXP.test(asset))
  .filter((asset) => !/\.html$/.test(asset))
  .concat(...CACHED_PAGES_PATHNAMES)

const CACHED_RESOURCES_SET = new Set(CACHED_RESOURCES)

const CACHE_NAME = `my_pwa_v${ process.env.APP_VERSION }`


// cache generated by webpack files on installation
SW.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(CACHED_RESOURCES))
      .then(() => SW.skipWaiting())
  )
})

// clear unused caches on activation
SW.addEventListener('activate', (event) => {
  const cacheWhiteList = new Set([CACHE_NAME])

  event.waitUntil(
    caches.keys()
      .then((keyList) =>
        Promise.all(
          keyList.reduce<Promise<boolean>[]>((result, key) => {
            if (!cacheWhiteList.has(key)) {
              result.push(caches.delete(key))
            }

            return result
          }, [])
        )
      )
      .then(() => SW.clients.claim())
  )
})

// TODO add another extensions: fonts, images
function isRequestForCacheFirstStatic (request: Request): boolean {
  if (!request.url.startsWith(SW.registration.scope)) {
    return false
  }

  const requestPathname = request.url.slice(SW.registration.scope.length - 1)
  return CACHED_RESOURCES_SET.has(requestPathname)
}

SW.addEventListener('fetch', (event) => {
  if (isRequestForCacheFirstStatic(event.request)) {
    // cache-first for internal static
    event.respondWith(
      caches.open(CACHE_NAME)
        .then((cache) => cacheFirstStrategy(event, cache))
    )
    return
  }
})


function showNewMessageNotification (pushMessage: any): Promise<void> {
  const { tag, data } = pushMessage
  const { userName, userMessage, messageCount } = data

  return SW.registration.getNotifications()
    .then((notifications) => notifications.find((item) =>
      item.data && item.data.userName === userName
    ))
    .then((foundNotification) => {
      if (foundNotification) {
        const nextMessageCount = foundNotification.data.messageCount + messageCount

        return SW.registration.showNotification(`New messages from ${ userName }`, {
          body: `You have ${ nextMessageCount } new messages from ${ userName }`,
          tag,
          data: {
            userName,
            messageCount: nextMessageCount,
          },
          renotify: typeof tag === 'string',
          requireInteraction: true,
        } as NotificationOptions)
      }

      return SW.registration.showNotification(`New message from ${ userName }`, {
        body: `"${ userMessage }"`,
        tag,
        data: {
          userName,
          messageCount,
        },
        renotify: typeof tag === 'string',
        requireInteraction: true,
      } as NotificationOptions)
    })
}

function fetchAndShowNotification (messageId: number) {
  return fetch(`/api/v1/push/message/${ messageId }`)
    .then((response) => response.json())
    .then((responseBody) => showNewMessageNotification(responseBody.data))
    // .then((responseBody) => {
    //   const { title, body, icon, tag, data } = responseBody.data

    //   const actions = [
    //     {
    //       action: 'dismiss',
    //       title: 'Dismiss',
    //     },
    //     {
    //       action: 'learn-more',
    //       title: 'Learn More',
    //     },
    //   ]

    //   const options: NotificationOptions = {
    //     body,
    //     icon,
    //     tag,
    //     data,
    //   }

    //   return SW.registration.showNotification(title, {
    //     ...options,
    //     actions,
    //     renotify: typeof tag === 'string',
    //     requireInteraction: typeof tag === 'string',
    //   } as NotificationOptions)
    // })
}

SW.addEventListener('push', (event) => {
  const showMessagePromise = isClientFocused()
    .then((focused) => {
      if (focused) {
        return
      }

      const messageId = event.data ? Number(event.data.text()) : undefined
      if (typeof messageId !== 'number') {
        throw new Error(`Couldn't get message ID from push event`)
      }

      return fetchAndShowNotification(messageId)
    })

  event.waitUntil(showMessagePromise)
})


function focusOrOpenUrl (pathname: string) {
  const urlToOpen = new URL(pathname, SW.location.origin).href

  return SW.clients.matchAll({
    type: 'window',
    includeUncontrolled: true,
  })
  .then((windowClients) => {
    const matchedWindow = windowClients.find((item) => item.url === urlToOpen)

    return matchedWindow && (matchedWindow as any).focus
      ? (matchedWindow as any).focus()
      : SW.clients.openWindow(urlToOpen)
  })
}

SW.addEventListener('notificationclick', (event) => {
  const clickedNotification = event.notification
  clickedNotification.close()

  const promiseChain = Promise.resolve()
    .then(() => focusOrOpenUrl('/'))

  event.waitUntil(promiseChain)
})
